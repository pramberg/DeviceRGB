#include "/Engine/Private/Common.ush"
#include "/Engine/Private/ScreenPass.ush"

// Must match ESceneTextureId
#define PPI_PostProcessInput0 14
#define PPI_PostProcessInput1 15
#define PPI_PostProcessInput2 16
#define PPI_PostProcessInput3 17
#define PPI_PostProcessInput4 18

SCREEN_PASS_TEXTURE_VIEWPORT(PostProcessInput_0) 
SCREEN_PASS_TEXTURE_VIEWPORT(PostProcessInput_1)
SCREEN_PASS_TEXTURE_VIEWPORT(PostProcessInput_2)
SCREEN_PASS_TEXTURE_VIEWPORT(PostProcessInput_3)
SCREEN_PASS_TEXTURE_VIEWPORT(PostProcessInput_4)
SCREEN_PASS_TEXTURE_VIEWPORT(PostProcessOutput)

Texture2D PostProcessInput_0_Texture;
Texture2D PostProcessInput_1_Texture;
Texture2D PostProcessInput_2_Texture;
Texture2D PostProcessInput_3_Texture;
Texture2D PostProcessInput_4_Texture;

SamplerState PostProcessInput_0_Sampler;
SamplerState PostProcessInput_1_Sampler;
SamplerState PostProcessInput_2_Sampler;
SamplerState PostProcessInput_3_Sampler;
SamplerState PostProcessInput_4_Sampler;
SamplerState PostProcessInput_BilinearSampler;

#if SUPPORTS_INDEPENDENT_SAMPLERS
	#define PostProcessInput_0_SharedSampler PostProcessInput_0_Sampler
	#define PostProcessInput_1_SharedSampler PostProcessInput_0_Sampler
	#define PostProcessInput_2_SharedSampler PostProcessInput_0_Sampler
	#define PostProcessInput_3_SharedSampler PostProcessInput_0_Sampler
	#define PostProcessInput_4_SharedSampler PostProcessInput_0_Sampler
#else
	#define PostProcessInput_0_SharedSampler PostProcessInput_0_Sampler
	#define PostProcessInput_1_SharedSampler PostProcessInput_1_Sampler
	#define PostProcessInput_2_SharedSampler PostProcessInput_2_Sampler
	#define PostProcessInput_3_SharedSampler PostProcessInput_3_Sampler
	#define PostProcessInput_4_SharedSampler PostProcessInput_4_Sampler
#endif

StructuredBuffer<float2> LedUVs;
RWStructuredBuffer<float4> Colors;

#include "/Engine/Generated/Material.ush"

[numthreads(THREADGROUPSIZE_X, THREADGROUPSIZE_Y, THREADGROUPSIZE_Z)]
void MainCS(uint3 Gid : SV_GroupID, uint3 DTid : SV_DispatchThreadID, uint3 GTid : SV_GroupThreadID, uint GI : SV_GroupIndex)
{
    ResolvedView = ResolveView();
    float2 UV = LedUVs[DTid.x];
    
    FMaterialPixelParameters Parameters = MakeInitializedMaterialPixelParameters();
	FPixelMaterialInputs PixelMaterialInputs;

#if NUM_TEX_COORD_INTERPOLATORS
    UNROLL
	for (int CoordinateIndex = 0; CoordinateIndex < NUM_MATERIAL_TEXCOORDS; CoordinateIndex++)
	{
		Parameters.TexCoords[CoordinateIndex] = UV;
	}
#endif
    Parameters.VertexColor = 1;

    // Need to remap for the generated code to make sense... Slightly inefficient, but it beats
    // doing everything in the shader.
    float4 SvPosition = float4(UV * View_ViewSizeAndInvSize.xy, 0.0f, 1.0f);
    SvPosition.z = max(SvPosition.z, 1e-18);
    // fill out other related material parameters
	CalcMaterialParametersPost(Parameters, PixelMaterialInputs, SvPosition, true);

	// Grab emissive colour as output
	const float Alpha = GetMaterialOpacity(PixelMaterialInputs);
	Colors[DTid.x] = lerp(Colors[DTid.x], float4(GetMaterialEmissive(PixelMaterialInputs), Alpha), Alpha);
}